//! This the entry point of *akhiok-engine game client*
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]
#![warn(missing_docs)]
#![warn(clippy::all)]

pub mod gl_helper;
pub mod mesh;
pub mod texture;
/// Contains common datatypes used inside the engine.
pub mod datatypes {
    pub mod color;
    pub mod vectors;
}
/// Contains types used in the entity heirarchry structure.
pub mod entities {
    pub mod entity;
    pub mod entity_tree;
}
pub mod window;

use beryllium::video::{CreateWinArgs, GlSwapInterval};
use core::{convert::TryInto, mem::size_of};
use ogl33::*;
use std::ptr;

use crate::datatypes::color::Color3;
use crate::entities::entity::EntityType;
use crate::entities::entity_tree::EntityTree;
use crate::gl_helper::*;
use crate::mesh::*;
use crate::texture::*;
use crate::window::*;

/// The default window title
const WINDOW_TITLE: &str = "Test Window";

/// The path of the vertex shader
const VERT_SHADER: &str = "src/shaders/vert.glsl";
/// The path of the fragmentation shader
const FRAG_SHADER: &str = "src/shaders/frag.glsl";

// TODO: Error when loading meshes from files generated by mesh_convert.py

/// main function
fn main() {
    let bitmap = Texture::from_file("assets/awesomeface.png").unwrap();

    let win_args = CreateWinArgs {
        title: WINDOW_TITLE,
        width: 800,
        height: 600,
        allow_high_dpi: true,
        borderless: false,
        resizable: false,
    };

    let mut win = Window::new(win_args).unwrap();
    let gl_window = &win.window;
    gl_window.set_swap_interval(GlSwapInterval::Vsync).unwrap();

    unsafe {
        load_gl_with(|f_name| gl_window.get_proc_address(f_name.cast()));
    }

    clear_color(Color3::new(0.2, 0.3, 0.3).unwrap());

    win.init_objects(VERT_SHADER, FRAG_SHADER).unwrap();

    let mut entity_tree = EntityTree::default();
    let head = entity_tree.add_head();
    println!("{}", head.borrow().get_uuid());

    let base_entity = entity_tree.add_entity("new-entity", EntityType::Base);
    entity_tree
        .set_parent(base_entity.borrow_mut(), Some(head.borrow_mut()))
        .unwrap();

    let mut meshes: Vec<Mesh> = vec![];

    let mesh = Mesh::load_mesh_from_file("assets/meshs/plane.mesh").unwrap();
    let mesh2 = Mesh::load_mesh_from_file("assets/meshs/triangle.mesh").unwrap();
    meshes.push(mesh);
    meshes.push(mesh2);

    let mut texture = 0;
    unsafe {
        glGenBuffers(1, &mut texture);
        glBindTexture(GL_TEXTURE_2D, texture);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT as GLint);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT as GLint);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR as GLint);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR as GLint);
        glTexImage2D(
            GL_TEXTURE_2D,
            0,
            GL_RGBA as GLint,
            bitmap.width as GLsizei,
            bitmap.height as GLsizei,
            0,
            GL_RGBA,
            GL_UNSIGNED_BYTE,
            bitmap.pixels.cast(),
        );
        glGenerateMipmap(GL_TEXTURE_2D);
        bitmap.free();
    }

    win.shader_program.use_program();

    unsafe {
        let vertex_data_size = size_of::<VertexDataInternal>().try_into().unwrap();

        // position
        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, vertex_data_size, ptr::null());
        glEnableVertexAttribArray(0);

        // texture
        glVertexAttribPointer(
            1,
            2,
            GL_FLOAT,
            GL_FALSE,
            vertex_data_size,
            size_of::<[f32; 3]>() as *const _,
        );
        glEnableVertexAttribArray(1);
    }

    polygon_mode(gl_helper::PolygonMode::Fill);
    win.render_loop(&meshes);
    win.shader_program.delete();
}
